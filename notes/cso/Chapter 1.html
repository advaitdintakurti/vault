<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 1</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<blockquote>
<p>All information in a system is represented as a bunch of bits.</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;hello, world</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>hello.c</code> program is stored in a file and is organized
as 8-bit chunks called bytes. Each byte has an integer value that
corresponds to some character.</p>
<p>![[hello-world-ascii.png]]</p>
<blockquote>
<p>ASCII (American Standard Code for Information Interchange) is used
above.</p>
</blockquote>
<p>Files that only contain ASCII characters are called <em>text
files</em>, others are called <em>binary files.</em></p>
<h2 id="compilation">Compilation</h2>
<p>In order to run hello.c on the system, the individual C statements
must be translated into a sequence of low-level machine-language
instructions.</p>
<p>These instructions are then packaged in a form called an executable
object program and stored as a binary disk file. Object programs are
also referred to as executable object files.</p>
<p>![[compilation-system.png]] The <code>gcc</code> compiler reads the
source file <code>hello.c</code> and translates it into an executable
object file <code>hello</code>.</p>
<h4 id="preprocessor-cpp">Preprocessor (<code>cpp</code>)</h4>
<p>Modifies the original C program according to directives that begin
with the ‘<code>#</code>’ character.</p>
<p>For example, the<code>#include &lt;stdio.h&gt;</code> command of
<code>hello.c</code> tells the preprocessor to read the contents of
<code>stdio.h</code> and insert it directly into the program text. The
resulting C program has a <code>.i</code> suffix.</p>
<h4 id="compiler-cc1">Compiler (<code>cc1</code>)</h4>
<p>The compiler (<code>cc1</code>) translates the text file
<code>hello.i</code> into the text file <code>hello.s</code>, which
contains an assembly-language program. This program includes the
following definition of function main: ![[hello-world-asm.png|300]]</p>
<h4 id="assembler-as">Assembler (<code>as</code>)</h4>
<p>The assembler (<code>as</code>) translates <code>hello.s</code> into
machine-language instructions, packages them in a form known as a
<em>relocatable object program</em>, and stores the result in the object
file <code>hello.o</code>, which is a binary file.</p>
<h4 id="linker-ld">Linker (<code>ld</code>)</h4>
<p>Our <code>hello.c</code> program calls the <code>printf</code>
function, which is part of the standard C library. The printf function
resides in a separate precompiled object file called
<code>printf.o</code>, which must be merged with <code>hello.o</code>.
The linker (<code>ld</code>) handles this merging. The result is the
hello file, which is an executable object file that is ready to be
executed.</p>
<h4 id="understanding-compilation-systems-helps-with">Understanding
compilation systems helps with:</h4>
<ul>
<li>Writing code that is more optimized.</li>
<li>Understanding link-time errors which are hard to catch.</li>
<li>Avoiding security holes.</li>
</ul>
<h3 id="execution">Execution:</h3>
<p>The C program <code>hello.c</code> has been converted to an
executable <code>hello</code> by the compilation process. To run the
executable, we type its name on a <strong>shell.</strong></p>
<pre><code>&gt; ./hello
hello, world</code></pre>
<p>The shell is a command-line interpreter that prints a prompt, waits
for you to type a command, and then performs the command.</p>
<p>In this case, the shell loads and runs the <code>hello</code> program
and then waits for it to terminate.</p>
<h2 id="hardware-organization">Hardware Organization</h2>
<p>![[hw-organization.png]]</p>
<h4 id="buses">Buses</h4>
<p>Buses carry information back and forth between components. They are
designed to transfer fixed-size chunks of bytes known as words. Most
machines today have word sizes of either 4 bytes (32 bits) or 8 bytes
(64 bits).</p>
<h4 id="io-devices">I/O Devices</h4>
<p>Input/Output (I/O) devices connect the system to the external world.
Each I/O device is connected to the I/O bus by either a
<em>controller</em> or an <em>adapter</em>.</p>
<ul>
<li><strong>Controller:</strong> Chipsets on the device itself or on the
motherboard.</li>
<li><strong>Adapter</strong>: Card that plugs into a slot on the
motherboard.</li>
</ul>
<h4 id="memory">Memory</h4>
<p>The main memory is a temporary storage device that holds both a
program and the data it manipulates while the processor is executing the
program. Physically, main memory consists of a collection of dynamic
random access memory (DRAM) chips. Logically, memory is organized as a
linear array of bytes, each with its own unique address (array index)
starting at zero.</p>
<h4 id="processor">Processor</h4>
<p>The <strong>Central Processing Unit (CPU)</strong> is the core
component that interprets and executes instructions stored in main
memory. At its core lies the <strong>Program Counter (PC)</strong>, a
register that holds the address of the next instruction to execute.</p>
<p>From power-on to power-off, the processor continuously executes the
instruction at the PC, interprets it, performs the required operation,
and updates the PC to the address of the next instruction, which may not
always be contiguous.</p>
<p><strong>Instruction Set Architecture (ISA):</strong> Defines the
effects of machine-code instructions, ensuring instructions execute in
sequence through a series of steps: - <strong>Fetch:</strong> Read the
instruction from memory at the PC. - <strong>Decode:</strong> Interpret
the instruction bits. - <strong>Execute:</strong> Perform the specified
operation. - <strong>Update:</strong> Adjust the PC to the next
instruction.</p>
<p><strong>Register File:</strong> A small, fast storage containing
multiple word-sized registers with unique names.</p>
<p><strong>Arithmetic/Logic Unit (ALU):</strong> Performs computations
to produce new data or address values.</p>
<p>Here are some examples of the simple operations that the CPU might
carry out at the request of an instruction:</p>
<ul>
<li><strong>Load:</strong> Transfer a byte or word from memory to a
register.</li>
<li><strong>Store:</strong> Transfer a byte or word from a register to
memory.</li>
<li><strong>Operate:</strong> Use the ALU to compute results from two
registers and store them in another.</li>
<li><strong>Jump:</strong> Update the PC with a specific address from
the instruction.</li>
</ul>
<h3 id="running-hello">Running <code>hello</code></h3>
<p>![[running-hello-1.png|600]] Initially, the shell program is
executing its instructions, waiting for us to type a command.</p>
<p>As we type <code>./hello</code> on the keyboard, the shell program
reads each one into a register and then stores it in memory</p>
<p>When we hit the enter key on the keyboard, the shell loads the
executable <code>hello</code> file by executing a sequence of
instructions that copies the code and data in the <code>hello</code>
object file from disk to main memory.</p>
<p>![[running-hello-2.png|500]]</p>
<p>Using a technique called <em>direct memory access (DMA)</em>, the
data travels directly from disk to main memory.</p>
<p>![[running-hello-3.png|550]] Once the code and data in the
<code>hello</code> object file are loaded into memory, the processor
starts executing the instructions in the <code>hello</code> program’s
main routine. These instructions copy the bytes in the
<code>hello, world\n</code> string from memory to the register file, and
from there to the display device, where they are displayed on the
screen.</p>
<h3 id="cache">Cache</h3>
<p>Copying information from one place to another is a big overhead that
slows down the process of execution, and thus we need to make the copy
operations <em>as fast as possible.</em></p>
<blockquote>
<p>Because of physical laws, larger storage devices are slower than
smaller ones. A typical register file stores only a few hundred bytes of
information, as opposed to billions of bytes in the main memory.
However, the processor can read data from the register file almost 100
times faster than from memory. This causes a processor–memory gap in
speed.</p>
</blockquote>
<p>To deal with the difference in speed system designers include
smaller, faster storage devices called <em>cache memories</em> (or
simply <em>caches</em>) that serve as temporary staging areas for
information that the processor is likely to need in the near future.
![[cache.png]]</p>
<p>The cache are divided into tiers, with (inversely) varying sizes and
access speeds.</p>
<ul>
<li><strong>L1 Cache:</strong> Holds tens of thousands of bytes and can
be accessed nearly as fast as the register.</li>
<li><strong>L2 Cache:</strong> Holds 10-100 times as much as the L1
cache, but is also around 5 times slower.</li>
<li><strong>L3 Cache:</strong> Newer and more powerful systems also have
a third level of cache.</li>
</ul>
<p>These caches are implemented with a hardware technology known as
static random access memory.</p>
<h3 id="memory-hierarchy">Memory Hierarchy</h3>
<p>The storage devices in a computer system are organized in a
<em>memory hierarchy</em>.</p>
<p>![[memory-hierarchy.png]]</p>
<p>The main idea of a memory hierarchy is that storage at one level
serves as a cache for storage at the next lower level.</p>
<h2 id="operating-system">Operating System</h2>
<p>The operating system is a layer of software that connects application
programs to the hardware.</p>
</body>
</html>
